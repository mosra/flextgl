// WARNING: This file was automatically generated
// Do not edit.

#raw
#include "flextGL.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#end raw

void flextLoadOpenglFunctions(void);

static void open_libgl(void);
static void close_libgl(void);
static void *get_proc(const char *proc);
static void add_extension(const char* extension);

int flextInit(void) 
{
    open_libgl();
    flextLoadOpenglFunctions();
    close_libgl();

    GLint minor, major;

#if $version.major >= 3
    glGetIntegerv(GL_MAJOR_VERSION, &major);
    glGetIntegerv(GL_MINOR_VERSION, &minor);
#else
    if (!glGetString)
		return GL_FALSE;
	const char* p = (const char *) glGetString(GL_VERSION);
	if (!p)
		return GL_FALSE;
	for (major = 0; *p >= '0' && *p <= '9'; p++)
		major = 10 * major + *p - '0';
	for (minor = 0, p++; *p >= '0' && *p <= '9'; p++)
		minor = 10 * minor + *p - '0';
#end if

    if (major < $version.major || (major == $version.major && minor < $version.minor)) {
        fprintf(stderr, "Error: OpenGL version $(version.major).$(version.minor) not supported.\n");
        fprintf(stderr, "       Your version is %d.%d.\n", major, minor);
        fprintf(stderr, "       Try updating your graphics driver.\n");
        return GL_FALSE;
    }

#if $version.major*10 + $version.minor >= 32
    GLint profile;
    
    glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &profile);

#if $version.core
    if ((profile & GL_CONTEXT_CORE_PROFILE_BIT) == 0){ 
        fprintf(stderr, "Error: This application requires a core profile\n");
        return GL_FALSE;
    }
#elif $version.major >= 3 and $version.minor >= 2
    if ((profile & GL_CONTEXT_COMPATIBILITY_PROFILE_BIT) == 0) {
        fprintf(stderr, "Error: This application requires a compatibility profile\n");
        return GL_FALSE;
    }
#end if
#end if

#if $version.major < 3
    GLubyte* extensions = strdup(glGetString(GL_EXTENSIONS));

    GLubyte *i = extensions;
    while (*i != '\0') {
        GLubyte *ext = i;
	while (*i != ' ' && *i != '\0') {
	    ++i;
	}
	while (*i == ' ') {
	    *i = '\0';
	    ++i;
	}
	
	add_extension(ext);
    }

    free(extensions);
#else
    GLint num_extensions;
    glGetIntegerv(GL_NUM_EXTENSIONS, &num_extensions);
    
    int i;

    for (i = 0; i < num_extensions; i++) {
        add_extension(glGetStringi(GL_EXTENSIONS, i));
    }
#end if

#for $extension,$required in $extensions.iteritems()
    
#if $required:
    if (!FLEXT_$extension) {
        fprintf(stderr, "Error: OpenGL extension $(extension) not supported.\n");
        fprintf(stderr, "       Try updating your graphics driver.\n");
        return GL_FALSE;
    }
#end if   
#end for

    return GL_TRUE;
}



void flextLoadOpenglFunctions(void)
{
    // --- Function pointer loading
#for $category in $categories
#if $functions.has_key($category) and len($functions[$category]) > 0 and $category not in ['VERSION_1_0', 'VERSION_1_1','VERSION_1_0_DEPRECATED', 'VERSION_1_1_DEPRECATED' ]

    // $category

#for $function in $functions[$category]
    glpf$function.name = (PFNGL$(function.name.upper())PROC)get_proc("gl$function.name");
#end for
#end if
#end for
}

// ----------------------- Extension flag definitions ---------------------- 
#for $extension,$required in $extensions.iteritems()
int FLEXT_$extension = GL_FALSE;
#end for

// ----------------- Function pointer definitions ----------------

#for $category in $categories
#if $functions.has_key($category) and len($functions[$category]) > 0 and $category not in ['VERSION_1_0', 'VERSION_1_1','VERSION_1_0_DEPRECATED', 'VERSION_1_1_DEPRECATED' ]
#for $function in $functions[$category]
PFNGL$(function.name.upper())PROC glpf$(function.name) = NULL;
#end for
#end if
#end for

static void add_extension(const char* extension)
{
#for $extension,$required in $extensions.iteritems()
    if (strcmp("GL_$(extension)", extension) == 0) {
        FLEXT_$(extension) = GL_TRUE;
    }
#end for
}

#raw

// get_proc from Slavomir Kaslev's gl3w.

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>

static HMODULE libgl;

static void open_libgl(void)
{
	libgl = LoadLibraryA("opengl32.dll");
}

static void close_libgl(void)
{
	FreeLibrary(libgl);
}

static void *get_proc(const char *proc)
{
	void *res;

	res = wglGetProcAddress(proc);
	if (!res)
		res = GetProcAddress(libgl, proc);
	return res;
}
#elif defined(__APPLE__) || defined(__APPLE_CC__)
#include <Carbon/Carbon.h>

CFBundleRef bundle;
CFURLRef bundleURL;

static void open_libgl(void)
{
	bundleURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
		CFSTR("/System/Library/Frameworks/OpenGL.framework"),
		kCFURLPOSIXPathStyle, true);

	bundle = CFBundleCreate(kCFAllocatorDefault, bundleURL);
	assert(bundle != NULL);
}

static void close_libgl(void)
{
	CFRelease(bundle);
	CFRelease(bundleURL);
}

static void *get_proc(const char *proc)
{
	void *res;

	CFStringRef procname = CFStringCreateWithCString(kCFAllocatorDefault, proc,
		kCFStringEncodingASCII);
	res = CFBundleGetFunctionPointerForName(bundle, procname);
	CFRelease(procname);
	return res;
}
#else
#include <dlfcn.h>
#include <GL/glx.h>

static void *libgl;

static void open_libgl(void)
{
	libgl = dlopen("libGL.so.1", RTLD_LAZY | RTLD_GLOBAL);
}

static void close_libgl(void)
{
	dlclose(libgl);
}

static void *get_proc(const char *proc)
{
	void *res;

	res = glXGetProcAddress((const GLubyte *) proc);
	if (!res)
		res = dlsym(libgl, proc);
	return res;
}
#endif

#end raw
